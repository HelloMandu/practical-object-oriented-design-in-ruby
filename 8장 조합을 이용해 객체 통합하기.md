 # 조합을 이용해 객체 통합하기
- 객체지향 조합을 이용하면 간단하고 독립적인 객체를 보다 크고 복합적인 것으로 통합할 수 있다
- 조합에서 좀 더 큰 객체는 자신의 부분들을 가지고 있는(has-a) 관계를 맺는다
- 부분이란 곧 역할이며 주어진 역할을 수행하는 어떤 객체와도 즐겁게 협업할 수 있다

## 8.1 자전거 부품 조합하기

### 8.1.1 Bicycle 클래스 업데이트하기

### 8.1.2 Parts의 상속 관계 만들기

## 8.2 Parts 객체 조합하기

### 8.2.1 Part 만들기

### 8.2.2 Parts를 보다 배열과 비슷하게 만들

## 8.3 Parts 생산하기

### 8.3.1 PartsFactory(부품 공장) 만들기
- 다른 객체를 생산하는 객체를 팩토리라 부른다

### 8.3.2 PartsFactory 발전시키기

## 8.4 조합된 Bicycle

### 집합(Aggregation): 새로운 종류의 조합(Composition)
- 한 객체가 전달받은 메시지를 단순히 다른 객체에게 전달하는 것을 위임이라고 한다.
- 조합된 객체는 잘 정의된 인터페이스를 통해 협업할 줄 아는 여러 부분들로 구성되어 있다.
- 조합은 가지고 있는 관계(has-a)이다.
- 집합이란 포함된 객체가 독립적으로 존재할 수 있는 조합을 뜻한다.

## 8.5 상속과 조합 중 하나 선택하기
- 고전적 상속을 코드를 배치하는 기술이라는 점을 기억하자.
- 객체들을 상속 관계 속에 배치한 대가로 메시지 전달을 공짜로 얻게 되었다고 생각하자.
- 조합은 이 대가와 이득을 뒤집은 것으로 독립적으로 존재하며 직접 메시지를 전달해야 한다.
- *조합이 해결할 수 있는 문제라면 조합을 사용하자 조합은 상속보다 내재적으로 훨씬 적은 의존성을 가지고 있다.

### 8.5.1 상속의 결과 받아들이기


#### 상속의 이점
- 코드의 네 가지 목표 투명, 적절, 사용가능, 모범이 되어야 하는데 상속은 2, 3, 4번째 목표를 훌륭히 수행한다.
- 상속 관계의 위쪽에 정의된 메서드는 강력한 영향력을 가지며 제대로 구조화된 상속 관계는 매우 적절하다(resonable).
- 상속 관계는 확장에 열려있고, 수정에는 닫혀있다. 새로운 클래스를 추가할 때 기존 코드를 수정하지 않아도 되기 때문에 상속 관계는 사용가능(usable)하다.
- 하위클래스를 만들려는 프로그래머는 기존 코드를 자연스럽게 참조할 수 있다. 때문에 상속 관계는 모범이 된다(exemplary).
- 상위클래스와 하위클래스 사이의 is-a 관계는 공통의 추상화 코드를 공유해 정리하는 가장 최적화된 방법이다.

#### 상속의 비용
- 상속을 사용하는데 우려되는 사항 두 가지
    - 상속이 어울리지 않는 문제를 해결하는데 상속을 사용할 수 있다.
    - 상속이 문제를 해결하기 위한 적절한 방법일지라도 다른 프로그래머가 바라지 않는 방식으로 사용할 수 있다. 즉 의존성을 받아들이고 싶지 않을 수 있다.
    
- 적절함(resonable)의 반대편에는 잘못된 상속 관계 속에서 코드를 수정할 대 매우 큰 비용이 발생한다는 문제가 있다. 작은 수정 하나가 모든 것을 엉망으로 만들어 버린다.
- 사용가능성(usable)의 반대쪽에는 새로운 행동을 추가할 수 없는 상황이 있다.
- 모범이 됨(exemplary)의 반대편에는 잘못된 상속 관계를 확장하려 했을 때 만들어 내는 혼란이 숨어 있다.
- 상위클래스로부터의 의존성으로 인해 작은 부분을 수정해도 코드의 넓은 영역에 거대한 영향을 미칠 수 있다.

### 8.5.2 조합의 결과 받아들이기
- '상속을 통해 만들어진 객체'와 '조합을 사용하는 객체'는 두가지 지점에서 다르다
    - 조합된 객체는 상속 관계에 의존하지 않는다
    - 수신한 메시지를 직접 전달한다
    
#### 조합의 이점
- 명료한 인터페이스를 갖는 작은 객체를 여럿 만들게 되는 경향이 있다. 작은 객체들은 하나의 책임만을 갖고 있고, 자신의 행동을 직접 명시하고 있는 투명한(transparent) 객체들이다.
- 상속구조의 위쪽에서 발생한 변화로부터 덜 영향을 받는다
- 자신의 부분들을 인터페이스를 통해 관리하기 때문에 한 부분을 새로 추가하는 것이 보다 쉽다.
- 조합된 객체의 관점에서 보자면 한 부분의 변형된 형태를 추가한다는 것은 충분히 적절한(resonable)한 것이며 자기 내부의 코드는 수정하지 않아도 된다.
- 구조적으로 독립되어 있는 인터페이스를 가지고 있기 때문에 서로 대체할 수 있는 요소로 만들어주며, 결국 새로운 환경에서도 손쉽게 사용할(usable) 수 있다.

#### 조합의 비용
- 각각의 부분이 작고 쉽게 이해할 수 있더라도, 이 부분들이 모여 전체가 작동하는 방식은 훨씬 불명확할 수 있다. 
- 개별 부분들은 투명(transparent)하더라도 전체는 그렇지 않을 수 있다.

### 8.5.3 올바른 관계 선택하기
- 객지지향 고수들의 상속과 조합에 대한 조언
    - 상속은 특수화이다
    - 상속은 이미 존재하는 클래스들에 상대적으로 적은 양의 새로운 코드를 추가하는 상황에 어울린다
    - 주어진 행동의 자신의 부분들의 총합 이상일 때 조합을 사용하라
    
#### is-a 관계에서 상속 사용하기
- 현실세계에서 볼 수 있는 물체 중 고정적이고 일반-특수의 상속 관계가 뚜렷한 것은 고전적 상속으로 구조화하기 좋은 대상이다.
- 상속관계의 범위가 좁아 이해하기 쉽고, 의도가 잘 드러나며, 쉽게 확장할 수 있는 객체들은 상속의 성공적 사용의 기준에 부합한다.
- 새로운 종류의 객체가 많이 추가되어 상속구조가 지나치게 확장되거나 자연스럽게 추가하기 어려운 상황이 온다면 그때 가서 새로운 디자인을 고민하면 된다.

#### behaves-like-a 관계에는 오리타입을 사용하라
- 어떤 상황에서는 여러 개의 객체가 같은 역할을 수행해야 하는 상황을 만든다
- 코드 속에 숨어 있는 역할을 알아 볼 수 잇는 두 가지 방법이 있다.
    - 객체가 역할을 수행하고 있지만, 객체의 핵심적인 책임이 아닌 경우
    - 코드의 여러 곳에서 특정 역할을 수행하려고 하는 경우
    
- 역할을 이해할 때 수행하는 객체의 관점이 아니라, 역할을 부여하는 객체의 관점에서 생각해보면 좋다.
- 역할이 존재한다는 것을 인지하면 오리 타입을 만들어 인터페이스를 정의하고 모든 수행자들이 따를 수 있는 인터페이스를 구현해야 한다.

#### has-a 관계에서 조합 사용하기
- is-a와 has-a 사이의 구분은 상속과 조합 사이에서 어떤 디자인을 선택할지를 결정하는 데 핵심적인 요소이다.
- 객체가 많은 부분을 가지고 있을수록 조합을 사용해서 객체를 디자인하는 것이 더 어울린다.
- 몇 가지 변형된 형태만들 갖는 특정 부품들을 만날 수 있는데 이것들은 상속을 사용하기 좋은 대상들이다.

## 8.6 요약
- 조합을 이용하면 작은 부분들을 가지고 복잡한 객체를 만들 수 있다.
- 조합된 객체는 간단하고 독립적인 개체들로 이루어지는 경향이 있고 새롭게 조합하고 재배치하기 쉽다.
- 간단한 객체는 이해하기 쉽고 재사용하고 테스트하기 용이하다.
- 작은 객체들이 모여 복잡한 하나의 전체를 이루기 때문에 애플리케이션 전체의 작동 방식은 개별 부분들만큼 이해하기 쉽지 않을 수 있다.
- 조합, 고전적 상소, 모듈을 통한 행동 공유는 서로 대립되는 코드 재배치 기술이며 각각은 나름의 비용과 이익을 제공한다.


### 각각을 제대로 사용하는 것은 경험과 판단력의 문제이다. 기술을 적극적으로 사용해보고 실수를 받아들이며 발전해가자!!
