# 오리 타입(Duck typing)으로 비용 줄이기
- 오리 타입은 특정 클래스에 종속되지 않은 퍼블릭 인터페이스이다.
- 오리 타입 객체는 클래스보다는 행동에 의해 규정되는 카멜레온이다.

## 5.1 오리 타입 이해하기
- 애플리케이션은 특정 클래스에 종속되지 않은 퍼블릭 인터페이스를 정의할 수 있다.
- 중요한 것은 객체가 무엇인가가 아니라 어떻게 행동하는가이다.
- 모든 객체가 예상한 바대로 움직인다고 믿을 수 있고, 어떤 타입이든 될 수 있다고 믿을 수 있다면 디자인의 무한한 가능성이 열릴 것이다.
- 클래스를 가로지르는 타입(across-class types) 오리타입은 명시적이고 정리된 계약서같은 퍼블릭 인터페이스를 가지고 있어야 한다.

### 5.1.1 오리타입 무시하기
- 특정 클래스에 의존하고 있지 않지만 특정 메서드에 반응할 수 있는 객체를 수신해야 한다는 사실에 의존할 수 있다.

### 5.1.2 문제가 더 복잡해지면
- 예상치 못한 상황에 봉착하면 새로운 객체가 이해할 수 있는 메시지를 찾아 해매곤 한다.
- 클래스에 따라 다르게 작동하는 case 구분을 가지고 객체들에게 올바른 메시지를 전송할 수는 있지만 이럴 경우 의존성 분출을 목격하게 될 것이다.
- 시퀀스 다이어그램은 언제나 코드보다 간단해야 한다. 그렇지 않다면 디자인에 뭔가 문제가 있다는 뜻이다.

### 5.1.3 오리 타입 찾기
- Object가 여행을 준비하길 원하는 Mechanic, TripCoordinator, Driver는 모두 Preparer 이고 이건 추상적인 생각이다.
- Preparer와 같은 퍼블릭 인터페이스는 아이디어로만 존재하고 디자인이 만들어낸 허구에 불과하다.

### 5.1.4 오리 타입을 사용해서 얻을 수 있는 이점
- 객체지향 디자인은 구체적은 코드를 작성하는 비용 그리고 추상적인 코드를 작성하는 비용 사이에서 자유로울 수 없다.
- 구체적인 코드는 이해하기 쉽지만 확장비용이 높고, 추상적인 코드는 처음에는 불명확해 보이지만 한 번 이해하고 나면 수정하기가 훨씬 쉽다.
- 오리타입을 사용하면 코드는 구체적인 것에서 추상적인 것으로 바뀐다.

### 폴리모피즘(polymorphism): 다형성
- 폴리모피즘은 여러 형태를 가지고 있는 상태를 의미한다.
- 객체지향 프로그래밍에서 폴리모피즘은 같은 메시지에 반응할 수 있는 여러 객체의 능력을 의미한다.
- 하나의 메시지가 여러개(poly) 형태(morphs)를 갖게 된다.
- 폴리모피즘을 구현하는 방법은 여러 가지가 있는데 오리 타입도 그 중 하나다. 

## 5.2 오리 타입을 사용하는 코드 작성하기

### 5.2.1 숨겨진 오리 타입 알아보기
- 몇 가지 일반적인 코딩 패턴은 오리 타입이 숨겨져 있다는 사실을 알려준다.
    - 클래스에 따라 변경되는 case 구분
    - kind_of? 와 is_a?
    - responds_to?
    
### 5.2.2 오리 타입을 믿기
- kind_of?, is_a?, responds_to? 와 같은 코드는 이렇게 말한고 있다. "나는 네가 누구인지 알고 있고, 그렇기 때문에 네가 무엇을 하는지도 알고 있다."
- 위와 같은 지식은 협업하는 객체에 대한 믿음이 부족하다는 사실을 말해주고 코드를 수정하기 어렵게 만드는 의존성을 불러온다.
- 위와 같은 스타일의 코드는 데메테르의 원칙을 위반했을 때처럼 어떤 객체 하나를 놓치고 있다는 걸 말해준다. 아직 퍼블릭 인터페이스를 발굴해내지 못한 어떤 객체가 있다는 뜻이다.

### 5.2.3 오리 타입 문서 작성하기
- 오리 타입을 만들었다면 문서도 작성하고 오리 타입의 퍼블릭 인터페이스 역시 테스트해야한다. 좋은 테스트는 그 자체로 최고의 문서일 수 있다.

### 5.2.4 오리 타입끼리 코드 공유하기
- 오리 타입이 공유하고 있는 것은 메서드 시그니처뿐이다. 인터페이스만을 공유할 뿐, 구현은 공유하지 않지만 종종 같은 행동을 공유할 필요가 있다. (7장)

### 5.2.5 현명하게 오리 타입 선택하기
- 오리타입을 만들지 말지는 우리의 판단에 달려있다. 디자인의 목표는 비용을 줄이는 것이다.
- 언어의 기본 클래스를 수정하는 방법은 몽키패칭(monkey patching)이라고 불리는데 어설프게 시도했다가는 큰 봉변을 당할 수 있다.
- 우리가 만든 클래스를 가지고 오리 타입을 구현하는 일과 언어의 기본 클래스를 가지고 오리타입을 만드는 일은 전혀 다른 이야기이고 대가도 다르다. 후자의 위험성이 훨씬 크다.

## 5.3 오리 타입을 무서워하지 않고 사용하기

### 5.3.1 정적 타입으로 오리 타입 거부하기
- 타입 확인을 추가하면 할수록 코드는 점점 덜 유연해지고 점점 더 클래스에 의존하게 된다. 새로운 의존성은 또 다시 타입실패(type failure)를 만들고, 계속해서 새로운 타입을 만들어 낸다
- 위와 같은 악순환에 빠져있는 프로그래머는 타입 문제를 해결하는 방법이 모든 타입 확인을 지워버리는 것이라는 사실을 믿지 못한다.

### 5.3.2 정적 타입 vs 동적 타입
- 정적 타입 애호가들은 다음과 같은 이점을 이야기한다.
  - 컴파일 시점에 컴파일러가 타입 에러를 잡아낼 수 있다.
  - 눈에 보이는 타입 정보가 문서의 역할을 한다.
  - 컴파일된 코드는 빠르게 동작할 수 있도록 최적화되어 있다.
  
- 정적 타입이 이점이 되는 경우
  - 컴파일러가 타입을 확인하지 않으면 런타임 타입에러 (runtime type errors)가 발생할 것이다.
  - 프로그래머는 전체 맥락에서 객체의 타입을 추측할 수 없고, 코드를 이해하지 못할 것이다.
  - 이러한 최적화를 거치지 않으면 애플리케이션이 너무 느릴 것이다.
  
- 동적 타입 지지자들은 아래와 같은 이점을 제시한다.
  - 코드가 해석되면(interpreted) 동적으로 로드(load)될 수 있다. compile/make 과정을 거칠 필요가 없다.
  - 소스 코드에 명시적인 타입정보를 포함할 필요가 없다.
  - [메타프로그래밍](https://ko.wikipedia.org/wiki/%EB%A9%94%ED%83%80%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D) 이 손쉽다.
  
- 동적 타입이 이점이 되는 경우
  - compile/make 과정이 없으면 전체 애플리케이션 개발이 보다 빠르게 진행된다.
  - 타입을 선언하는 코드가 없으면 프로그래머가 코드를 이해하기 쉽다. 맥락 속에서 객체의 타입을 추측할 수 있다.
  - 메타프로그래밍은 프로그래밍 언어의 바람직한 기능이다.

### 5.3.3 동적 타입 받아들이기
- 동적 타입 애플리케이션이 충분한 성능을 낼 수 있을 만큼 최적화되지 않는다면, 정적 타입만이 대안이다.
- 컴파일러는 의도치 않은 타입 에러로부터 우리를 구해주지 못한다. 타입 캐스팅을 사용하는 순간 모든 확신은 사라진다.
- 코드는 우리가 작성한 테스트만큼만 믿을 수 있을 뿐이고 런타임 실패는 여전히 발생할 수 있다.
- 오리 타입은 정적 타입 위에서 만들어진다. 오리 타입을 사용하기 위해서는 동적 타입을 받아들여야만 한다.

## 5.4 요약
- 오리 타입은 퍼블릭 인터페이스를 클래스로부터 분리해낸다.
- '객체가 누구인지' 가 아니라 '객체가 무엇을 하는지' 에 따라 가상의 타입을 만들어 낸다.
- 추상화에 의존할 때 애플리케이션의 위험성은 줄어들고 유연성은 증가한다.