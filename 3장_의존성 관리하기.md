# 의존성 관리하기
- 잘 디자인된 객체는 하나의 책임만 지고 있기 때문에 다른 객체와 협업하지 않을 수 없다.
- 서로 협업하려면 객체는 다른 객체에 대한 지식이 있어야하는데 지식은 의존성을 만들어 낸다.

## 3.1 의존성 이해하기
- 하나의 객체를 수정했을 때 다른 객체들을 뒤따라 수정해야 한다면 후자는 전저에 의존적이다.

### 3.1.1 의존성이 있다는 것을 알기
- 의존성을 갖는 조건
    - 다른 클래스의 이름의 클래스가 있다는 걸 알고 있다.
    - 자신을 제외한 다른 객체에게 전송할 메시지의 이름을 알고 있다.
    - 메시지가 필요로 하는 인자들을 알고 있다.
    - 인자들을 전달하는 순서를 알고 있다.
    
- 불필요한 의존성은 코드를 부적절하게 만든다.

### 3.1.2 객체들 간의 결합
- 의존성이 높은 객체들은 마치 하나인 듯 행동한다.
- 둘 이상의 객체가 강력하게 결합되어 있을 때 이들은 한 덩어리로 움직이고 하나만 재하용하는 것은 불가능하다.

### 3.1.3 다른 의존성들
- '자기자신을 제외한 다른 객체에게 전송할 메시지의 이름을 아는' 메시지 연쇄(message chaining)은 원래 있던 두 객체뿐만 이 아닌 최종 목표까지 거쳐갔던 모든 객체와 메시지들 사이에도 의존성을 만들어 낸다.
  ```이런 경우 데메테르의 원칙(Law of Demeter)이 위반되었다고 한다.```[LoD](https://en.wikipedia.org/wiki/Law_of_Demeter) 
    
- 의존성의 또 다른 영역은 테스트가 코드에 대해 갖은 의존성이다. 테스트-코드 사이의 지나친 결합은 코드-코드 사이의 지나친 결합과 같은 결과를 낳고 코드의 수정이 뒤이어 테스트의 수정을 강제한다.

## 3.2 약하게 결합된 코드 작성하기

### 3.2.1 의존성 주입하기(dependency injection)
- 중요한 것은 '객체의 클래스가 무엇인지' 가 아니라, '우리가 전송하는 메시지가 무엇인지' 이다.
- 하나의 객체가 다른 객체에 대한 너무 많은 것을 알고 있을수록 객체는 덜 유용해진다.

### 3.2.2 의존성 격리시키기
- 만약 제약조건이 너무 많아서 객체에 다른 객체를 주입(inject)할 수 없다면 클래스 내부에 격리시켜 놓을 필요가 있다.
- 의존성을 감추기 보단 더 잘 보이도록 만들어 재사용이 수월하도록하면 상황이 허락할 때 코드를 리팩터링 하기 쉽다.
- 외부에 대한 의존성을 걷어내고 클래스 내부의 메서드 속에 캡슐화 시켜 놓으면 메서드를 수정해야 하는 상황도 줄일 수 있다.
- 참조하는 지점을 격리시키는 것은 변화의 영향에 대응하기 위한 안전망을 제공한다.

### 3.2.3 인자 순서에 대한 의존성 제거하기
- 초기화 인자로 해시를 사용하기: 인자들의 순서에 대한 의존성을 제거했지만 위험도를 증가시킬 수 있다.
- 기본값을 사용하기
- 멀티파라미터 초기화를 고립시키기: 순서가 고정된 인자들을 옵션 해시로 대체해 애플리케이션을 보호

## 3.3 의존성의 방향 관리하기

### 3.3.1 의존성의 방향 바꾸기
- 애플리케이션은 변할 수밖에 없고 지금의 결정은 불확실한 미래에 영향을 미친다. 의존성의 방향은 이후 애플리케이션의 발전 과정에 뚜렷한 족적을 남긴다.

### 3.3.2 의존성의 방향 결정하기
- 의존성은 자기 자신보다 덜 변하는 객체들에 의존하는게 좋을 수 있다
  - 어떤 클래스는 다른 클래스에 비해 요구사항이 더 자주 바뀐다
  - 쿠체 클래스는 추상 클래스보다 수정해야하는 경우가 빈번히 발생한다
  - 의존성이 높은 클래스를 변경하는 것은 코드의 여러 곳에 영향을 미친다
  
- 변경될 가능성이 얼마나 높은지 이해하기: '다른 클래스와 비교해서 얼마나 더 변경되지 않는지' 를 기준으로 순위를 매겨볼 수 있다.
- 구체적인 것과 추상적인 것을 인지하기
  - 추상화된 인터페이스는 인터페이스가 기반하고 있던 구체 클래스보다 변경될 일이 훨씬 적기 때문에 추상화된 결과에 의존하는 것이 더 안전하다
  - "클래스"라는 표현은 일반적인 클래스뿐 아니라 인터페이스 역시 지칭하며 인터페이스도 의존성이 있기 때문에 디자인을 할 때 중요하게 고려한다.
  
- 의존성이 높은 클래스 만들지 않기: 이런 클래스를 가지고 있는 것 자체가 코드를 수정하게 싶지 않게 만든다.

## 3.4 요약
- 자기 자신보다 덜 변하는 것들에 의존하라.
- 의존성 관리는 미래를 견뎌낼 수 있는 애플리케이션을 만드는데 핵심적인 요소이다.
- 의존성 주입(dependency injection)은 느슨하게 결합된 객체, 창의적으로 재사용할 수 있는 객체를 만들어 준다.
- 의존성 관리의 핵심은 그 방향을 관리하는 것이다.
