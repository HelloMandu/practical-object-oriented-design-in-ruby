# 비용-효율적인 테스트 디자인하기

- 수정하기 쉬운 코드를 작성하는 일은 예술적인 작업이며 세 가지 기술이 필요하다
    1. 객체지향 디자인을 이해하고 있어야 한다.
       - 쉽게 바꿀 수 있는 코드가 잘 디자인된 코드이다.
    2. 코드 리팩터링하는 법을 익혀야 한다.
        - 코드를 여기저기로 옮기는 것이 아닌 성숙하고 탄탄하게 정의된 의미에서의 리팩터링이 필요하다.
        - 리팩터링은 코드의 외적인 작동방식을 변경하지 않으면서도, 그 내부 구조를 발전시킨다.
        - 좋은 디자인은 최소의 비용으로 최대한 유연한 형태로 남아있을 수 있게 해준다. 언젠가 수정의 날이 왔을 때 현재 코드 구조가 새로운 요구사항을 받아들일 수 있다록 만드는게 리팩터링이다.
    3. 수정 가능한 코드를 작성하려면 높은 수준의 테스트를 짤 수 있어야 한다.
        - 테스트는 지속적인 리팩터링에 안정감과 확신을 준다

```잘 디자인된 코드는 수정하기 쉽고, 리팩터링은 하나의 디자인을 다른 디자인으로 변형시키는 방법이며, 테스트는 리팩터링의 두려움에서 우리를 해방시켜 준다.```

## 9.1 의도를 가지고 테스트하기

- 테스트는 버그를 줄여주고 문서의 역할을 하며 테스트를 먼저 작성하면 애플리케이션의 디자인이 향상된다.
- 테스트의 진정한 목표는 디자인의 목표와 같이 코드 작성 비용을 줄이는 것이다.
- 테스트를 작성하는 시간이 버그를 잡고 문서를 작성하고 테스트 코드를 디자인하는데 드는 시간보다 오래걸린다면 테스트는 의미가 없다.
- 테스트 작성 비용이 너무 높은 문제를 해결하기 위한 방법은 테스트를 더 잘 짤 수 있도록 수련하는 것이다.

### 9.1.1 테스트 의도를 알기

#### 버그 찾아내기
- 개발 초기 단계에서 버그를 찾아내면 코드를 일찍 올바르게 만들어 놓을 수 있고, 미래에 선택할 수 있는 디자인의 폭을 넓힐 수 있다.
- 코드가 계속 쌓여 가면 숨어있는 버그는 의존성을 만들어내고, 고치기 위해 여러 군데 수정해야 할 수 있다. 버그를 일찍 고치면 언제나 코드 작성 비용일 줄어든다.

#### 문서 제공하기
- 테스트만이 디자인에 대한 믿을 수 있는 문서를 제공한다.
- 종이 문서는 쓸모 없어지고 인간의 기억이 한계를 드러내는 시점에도 테스트가 들려주는 이야기는 여전히 유효하다.

#### 디자인 결정을 미루기
- 테스트는 디자인 결정을 안전하게 미룰 수 있도록 해준다.
- 정보가 부족해 '미뤄진(pending)' 결정의 지점들은 꼼수의 모양을 취하고, 잘 표현된 인터페이스 뒤에 숨어 있다.
- 테스트가 인터페이스에 기대고 있다면 인터페이스 밑에 숨겨진 구체적인 코드는 나중에 마음껏 리팩터링할 수 있다.
- 테스트는 인터페이스가 계속해서 올바르게 작동한다는 것을 확인해주고, 리팩터링 과정에서 테스트를 다시 작성할 필요도 없다.
- 의도적으로 인터페이스에 의존하는 테스트를 작성하면 안전하게 디자인 결정을 미룰 수 있다.

#### 추상화를 돕기
- 좋은 디자인은 추상화된 코드에 기대고 있는 작고 독립적인 객체들을 자연스럽게 만들어낸다.
- 추상화된 코드는 유연한 디자인 요소지만, 작은 대가를 지불해야 한다. 대가란 '추상화된 코드는 각각은 이해하기 쉽지만 코드 속에 전체의 작동을 명확하게 보여주는 지점이 없다'
- 코드 베이스가 확장되고 추상화된 코드가 여럿 자라나면, 점점 더 테스트가 필요해진다. 추상화된 디자인이 어느 순간에 도달하면, 테스트 없이는 안전하게 코드를 수정할 수 없는 수준에 도달하기 때문이다.
- 테스트는 모든 추상화된 인터페이스의 기록이기 때문에 우리의 작업을 지지해주는 기반이 된다.

#### 디자인의 결점 드러내기
- 테스트는 디자인의 결점을 드러내준다.
- 테스트를 작성하기 위한 준비 작업이 힘겹다면 코드에 너누 많은 맥락(context)이 있다는 듯이다.
- 객체 하나를 테스트하기 위해 다른 객체를 끌어와야 한다면 이 코드는 의존성이 높다는 뜻이다.
- 디자인이 나쁠 때 테스트는 힘들어진다.
- 테스트가 힘들 때 디자인이 나쁘다는 말은 성립하지 않는다. 테스트를 통해 개발 비용을 낮추려면 테스트의 대상이 되는 애플리케이션, 테스트 자체도 잘 디자인해야 한다.
- 우리의 목표는 최소한의 비용으로 테스트가 제공하는 이점을 최대한으로 누리는 것이므로 꼭 필요한 것만 테스트하는, 느슨하게 결합된 테스트를 작성해야 한다.

### 9.1.2 무엇을 테스트할지 알기
- 테스트에서 더 나은 가치를 얻기 위한 방법 중 하나는 테스트를 덜 짜는 것이다. 이를 위해서는 모든 것을 단 한 번만 테스트하고 제대로 된 곳에서 테스트해야 한다.
- 테스트에서 중복을 제거하면 애플리케이션 수정에 맞춰 테스트를 수정해야 하는 비용을 줄일 수 있고, 제대로 된 장소에 작성해 놓으면 꼭 필요한 순간에만 테스트를 수정해도 된다.
- 애플리케이션에 적용할 수 있는 디자인 원칙은 테스트에도 동일하게 적용할 수 있다. 모든 테스트는 클래스를 사용하는 또 하나의 객체일 뿐이다.
- 모든 객체에서 가장 안정적인 것은 퍼블릭 인터페이스이다. 가장 비효율적이고 불필요한 테스트는 객체 내부의 불안정한 세부사항을 테스트하는 것이다. 객체는 오직 자신의 퍼블릭 인터페이스에 속하는 메시지의 상태만 검증해야 한다.
- 들어오는 메시지에 대해서는 메시지가 반환하는 상태를 테스트한다. 밖으로 나가는 커맨드 메시지에 대해서는 메시지가 제대로 전송되었는지 테스트해야 하고 쿼리 메시지는 테스트할 필요가 없다.
   ```
    쿼리(query): 밖으로 나가는 메시지 중 애플리케이션에 별다른 영향을 미치지 않는 메시지, 송신자가 관심을 갖는 메시지
    커맨드(commands): 다른 객체에 영향을 미치는 메시지(파일을 만들거나 DB Insert하거나 옵저버가 관찰하거나)
   ```
- 퍼블릭 인터페이스만을 충실하게 따르면 프라이빗한 행동이 변경되어도 테스트 자체를 수정할 필요가 없다.

### 9.1.3 언제 테스트할지 알기
- 지나치게 결합된 코드를 작성한 이후에 테스트를 작성하기란 매우 어렵다. 테스트는 코드를 재사용하는 것인데 재사용할 수 있는 코드가 없기 때문이다.
- 테스트를 먼저 작성하면 객체를 처음 만드는 순간부터 재사용 가능성을 각인시켜 놓게 된다. 재사용할 수 없다면 테스트를 작성할 수도 없기 때문이다.
- 기본적으로는 테스트를 먼저 작성하는 것이 좋다.
  
### 9.1.4 어떻게 테스트할지 알기
- 테스트 주도 개발(Test Driven Development)와 행동 주도 개발(Behavior Driven Development)가 정반대의 것처럼 비쳐질 수 있지만 각자가 보다 중요하게 생각하는 가치에 준해 결정하면 된다.
    - BDD는 밖에서 안으로, 바깐쪽에 있는 객체들을 먼저 만들고 필요하지만 아직 만들지 않은 객체들을 mocking 하면서 안쪽으로 들어온다.
    - TDD는 안에서 밖으로, 보통 도메인 객체에 대한 테스트로 시작해서, 객체를 재사용하면서 바깥 층위의 테스트 코드를 작성한다.
    
## 9.2 들어오는 메시지 테스트하기
- 들어오는 메시지들은 퍼블릭 인터페이스, 즉 객체가 외부 세계에 보여지는 모습을 형성한다.
- 다른 객체들은 메시지의 시그니처와 반환 결과에 의존하고 있기 때문에 이 메시지들을 테스트해야한다.

### 9.2.1 사용하지 않는 인터페이스 제거하기
- 테스트 중인 객체가 들어오는 메시지를 직접 구현하지 않았다면 객체는 이 메시지에 의존하고 있을 수 있다.
- 들어오는 메시지가 딸린 객체가 가지고 있지 않다면 이 메시지는 테스트할 필요가 없다. 그냥 지워버리자.
- 이런 코드에 테스트를 추가하고 유지관리 비용을 쏟는 것은 낭비에 불과하다.

### 9.2.2 퍼블릭 인터페이스 검증하기
- 들어오는 메시지를 테스트하는 첫 번째 단계는 여러 상황에서 올바른 값을 반환하는지 확인하는 것이다.
- 객체의 특정 메서드가 새로운 객체를 만들고 사용한다면 테스트 이면의 코드에는 위험이 숨겨져 있다. 애플리케이션의 어딘가에서 수정이 발생했을 때 테스트가 고장 날 가능성이 얼마나 높은지를 결정한다.
- 거대한 객체들의 묶음을 가진 객체를 테스트한다면 그들 중 하나가 고장나면 매우 혼란스런 상황이 연출될 것이다.
- 이러한 문제들은 애플리케이션이 곧 마주하게 될 문제들의 징후에 불과하다.

### 9.2.3 테스트 중인 객체 고립시키기
- 객체를 독립적으로 테스트할 수 없다는 사실은 미래에 어떤 문제에 직면할 것이라는 징조이다.
- 주입된 객체의 클래스에 관심을 가지는게 아닌 특정 역할의 퍼블릭 인터페이스를 이루고 있어야 한다.
- 특정 객체를 주입하는 것과 인터페이스를 주입하는 것은 엄연히 다르다. 입력받은 객체의 클래스에 얽매이지 않고 보다 자유롭게 사고할 수 있을 때 더욱 다양한 디자인과 테스트를 시도해 볼 수 있다.

### 9.2.4 클래스를 사용해서 의존성 주입하기
- 클래스를 사용해 테스트한 경우는 특정한 경우에만 제대로 작동한다.
- 상황에 따라 클래스를 사용한 테스트가 충분할 수 있지만, 추상화된 코드를 테스트하는 것이 훨씬 나은 결과를 가져다줄 수 있는 경우도 있다.
- 극단적으로 만약 몇백개의 interface를 implements한 객체가 있다고 가정해보자. 해당 객체를 생성하는 비용이 매우 비싸다면 어떻게 해야할까? 또는 명백하지 않은 상황에서는 어떻게 해야 할까?

### 9.2.5 역할에 대한 의존성 주입하기
- 의존성 주입을 사용하는 궁극적인 이유는 이미 있는 코드를 수정하지 않고도 구체 클래스들을 서로 대체해서 사용하기 위함이다.
- OOD에선 구체클래스들이 특정한 역할 보다 자주 변하기 때문에 의존성을 주입하라고 가르친다.
- 실제 객체를 선택하면 실제 애플리케이션에서 발생하는 문제가 테스트에서도 포착되지만, 가짜 객체를 사용하면 테스트를 동화 속 세상에 가둬버릴 수 있다.