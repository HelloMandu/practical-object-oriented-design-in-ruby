# 유연한 인터페이스 만들기

- 애플리케이션은 클래스로 구성되어 있지만 메시지를 통해 정의된다.
- 디자인은 객체 사이를 가로지르는 메시지에 관심을 두어야 하고, 객체 사이의 소통은 언터페이스를 통해 이루어진다.

## 4.1 인터페이스 이해하기
- 밖으로 노출된 메서드가 클래스의 퍼블릭 인터페이스(public interface)를 구성한다.
- 클래스는 메서드를 구현하고 일부는 외부의 객체가 사용하기 위한 것이다. 때문에 이 메서드들이 클래스의 퍼블릭 인터페이스를 구성한다.
- 인터페이스는 가상의(virtual) 클래스를 정의하고 있는 것과 같다.

## 4.2 인터페이스 정의하기
- 클래스는 하나의 책임을 제대로 수행하기 위해 존해하며 수많은 메서드를 구현하고 있다.
- 레스토랑을 예로 퍼블릭 메서드 == 메뉴판, 프라이빗 메서드 == 부엌

### 4.2.1 퍼블릭 인터페이스
- 클래스의 핵심 책임(primary responsibility)를 드러낸다.
- 다른 객체에 의해 호출될 수 있다.
- 쉽게 변경되지 않는다.
- 다른 객체가 안정적으로 의존할 수 있다.
- 테스트를 통해 꼼꼼하게 문서화되어 있다.

### 4.2.2 프라이빗 인터페이스
- 세부적인 구현을 담당한다
- 다른 객체에 의해 호출되지 않는다.
- 필요에 따라 언제든 변경할 수 있다.
- 다른 객체가 의존하기에는 위험하다.
- 테스트에서 다루지 않을 수도 있다.

### 4.2.3 책임, 의존성 그리고 인터페이스
- 클래스의 퍼블릭 인터페이스는 클래스의 구체적인 책임을 표현한 문장과 조응한다.
- 의존성을 관리할 때 자신보다 덜 변하는 클래스에 의존해야 한다. 클래스를 퍼블릭한 부분과 프라이빗한 부분으로 구분하면 덜 변화하는 것에 의존해야 한다는 생각은 클래스 내부에도 적용된다.
- 퍼블릭한 부분은 안정적인 부분이고 프라이빗한 부분은 변경될 수 있는 부분이다.
- 퍼블릭과 프라이빗을 규정할 때 클래스 사용자에게 어떤 메서드에 의존하는 것이 보다 안정적인지 알려주는 것이다.
- 퍼블릭 메서드를 사용할 때 메서드가 안정적이기를 기대한다.

## 4.3 퍼블릭 인터페이스 찾아내기

### 4.3.1 예시 애플리케이션: 자전거 여행 회사
- 예시를 보고 간단한 요구사항을 생각해보자.

### 4.3.2 의도를 구성하기
- 여행객, 여행, 여행길, 자전거, 정비공 정도의 클래스를 떠올릴 수 있다.
- 정보(data)와 행동(behavior) 둘다를 가지고 있는 도메인 객체(domain objects)는 매우 명시적이고 데이터베이스에서도 표현된다.
- 
### 4.3.3 시퀀스 다이어그램 사용하기
- 시퀀스 다이어그램은 통합 도멜링 언어(UML, Unified Modeling Language)로 정의되어 있다.
- 객체들의 배치와 메시지 전송 전력에 대해 검토해 볼 수 있는 간단한 방법을 제공한다.
- 다이어그램은 객체들이 주고받는 메시지를 명시적으로 드러내준다. 클래스를 결정하고 클래스의 책임을 찾아 나서는 대신 메시지를 결정하고 누구에게 전송할지 찾아보자.
- 클래스 기반 디자인에서 메시지 기반의 디자인 관점은 훨씬 유연한 애플리케이션을 만들 수 있게 해준다. (클래스가 무엇을 해야하는지 알 수 있기 때문)
```객체를 가지고 있기 때문에 메시지를 보내는 것이 아니라 메시지를 전송하기 때문에 객체를 갖는 것이다.```
- 자신이 무엇을 원하는지를 알아야 할 뿐 아니라 다른 객체들이 어떻게 협업해야 하는지도 알아야 한다.

### 4.3.4 '어떻게(How)'해야 하는지 말해주지 말고, '어떤 것(What)'을 달라고 요구하기
- 송신자(sender)가 원하는 것을 요구하는 메시지와 수신자(receiver)가 어떻게 행동해야하는지 알려주는 두 메시지를 구분하자.

### 4.3.4 주어진 맥락에서 독립적일 수 있게 하기
- 객체가 필요로 하는 맥락은 객체의 재사용성에 바로 영향을 미친다.

### 4.3.6 다른 객체를 믿기

### 4.3.7 새로운 객체를 찾아내기 위해 메시지를 사용하기

### 4.3.8 메시지 기반 애플리케이션 만들기
- 우리의 관심을 객체에서 메시지로 옮기면서 퍼블릭 인터페이스를 기반으로 애플리케이션을 디자인하는데 집중할 수 있다.

## 4.4 자신의 인터페이스를 드러내는 코드 작성하기
- 디자인 능력과 훈련 정도는 인터페이스의 명료함을 통해 드러난다.
- 애플리케이션의 특징을 드러내고 그 미래를 결정하는 것은 인터페이스이다.

### 4.4.1 명시적인 인터페이스 만들기
- 다른 사람이 우리가 작성한 메서드를 실행할 때 어떤 메서드에 의존해도 괜찮은지 알려줄 의무가 있다.
- 퍼블릭 인터페이스는 다음과 같아야 한다
    - 일반적인 의미, 엄밀하고 명시적으로 규정되어 있어야 한다.
    - 어떻게보다는 어떤 것에 대해 말해야 한다.
    - 예측할 수 있는 한도에서 바뀌지 않을 이름을 지어야 한다.
    - 추가적인 인자(options parameter)를 해시로 받아라
    
- private, protected 와 같은 키워드는 제약조건이라기보다 부드러운 방어막 같은 것이다. 이 키워드들을 사용한다는 의미는 다음과 같다.
    - 오늘의 내가 미래의 프로그래머보다 더 나은 정보를 알고 있다고 믿는다.
    - 내가 지금 불안정한 메서드라고 생각한 것을 미래의 프로그래머가 실수로 사용하지 못하게 만들어야 한다고 생각한다.
    
### 4.4.2 다른 이의 퍼블릭 인터페이스를 존중하자
- 다른 클래스와 협업할 때는 그 클래스의 퍼블릭 인터페이스만 사용하도록 노력해야 한다.
- 프라이빗 인터페이스에 의존하고 있다면 변화에 영향을 받을 위험이 증가한다.

### 4.3.3 프라이빗 인터페이스에 의존할 때는 특별히 주의를 기울어야 한다.
- 프라이빗 인터페이스에 의존할 수밖에 없는 순간이 있는데 매우 위험하기 때문에 의존성을 고립시켜 위험을 최소화 해야한다.

### 4.4.4 최소한의 맥락 속에 위치시키기
- 퍼블릭 인터페이스를 구성할 때는 다른 객체들과의 연계되어 있는 맥락을 최소화 할 수 있는 방향을 염두에 두자. 어떤 것과 어떻게 사이의 구분을 기억하자.
- 퍼블릭 인터페이스가 없거나 퍼블릭 인터페이스가 잘못 정의된 클래스가 시키는 대로 따르지 말자.

## 4.5 데메테르의 원틱
- [데메테르의 원칙(LoD)](https://en.wikipedia.org/wiki/Law_of_Demeter) (the Law of Demeter)은 객체들의 결합도를 낮추면서 코딩할 수 있도록 해주는 규칙이다.

### 4.5.1 데메테르 원칙 정의
- 이 원칙을 메서드가 메시지를 전송하지 말 것을 요구한다. 메시지를 전달받은 객체가 바로 이어 다른 타입의 객체에게 메시지를 전달하는 것을 금지한다.

### 4.5.2 위반의 결과
- 메시지 연쇄를 통해 접근한 어트리뷰트의 값을 변경하지 않는다는 전제 아래서만 이런 접근은 허용된다.

### 4.5.3 데메테르의 원칙을 위반하지 않기
- 메시지를 위임(delegation)을 사용하는 방법이 있다. 레퍼 메서드(wrapper method)를 통해 메시지를 다른 객체에게 넘겨 메시지 연쇄에 포함되어 있는 지식을 캡슐화하거나 감춘다.
- 위임을 통해 코드의 강한 결합을 감추는 것은 코드의 결합도를 낮추는 것이 아니다.

### 4.5.4 데메테르의 원칙에 귀 기울이기
- 데메테르의 원칙이 말하려는 것은 "위임을 많이 사용하자"가 아니다.
- customer.bicycle.wheel.rotate 같은 메시지 연쇄는 멀리 떨어져 있는 원하는 행동을 어떻게 가져올지 알고, 여러 객체들을 어떻게 타고가야하는지 알고 있는 것이다.
- 메시지 연쇄의 한 부분을 변경하면 나머지 부분도 변경해야 하는 위험성이 높아진다.
- 어떤 것을 원하는지 판단하면서 디자인 했다면 customer.ride 같은 메시지를 디자인 했을 것이다.
- 메시지 기반의 관점을 취하면 새로운 메시지를 발견할 수 있고 퍼블릭 인터페이스가 된다. 그리고 퍼블릭 인터페이스를 정의할 새로운 객체를 발견할 수 있다.
- 반면 도메인 객체(domain objects)의 족쇄를 벗어버리지 못하면 퍼블릭 인터페이스를 이용해 메시지 연쇄를 작성하게 될 것이다.

## 4.6 요약
- 객체 지향 애플리케이션은 객체들이 서로 주고받는 메시지를 통해 정의된다.
- 메시지들은 '퍼블릭' 인터페이스를 타고 흐른다.
- 메시지에 집중하면, 미처 파악하지 못했던 객체를 찾을 수 있다.
- '수신자가 어떻게 행동해야 하는지' 를 알려주기보다 수신자를 믿고 전송자가 원하는 바를 말해준다면 퍼블릭 인터페이스를 보다 유연하고 재사용할 수 있게 만들 수 있다.

